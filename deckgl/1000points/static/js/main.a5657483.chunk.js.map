{"version":3,"sources":["App.js","index.js"],"names":["INITIAL_VIEW_STATE","longitude","latitude","zoom","lastFrameTime","frameCount","currentFrame","timelineDates","buildingsCount","pointsCount","SHP_URL","POINT_URLS","TERRAIN_URL","colorScale","chroma","scale","domain","scaleLinear","range","App","state","jsonData","animatedData","shpData","terrainData","terrainBoundingBox","mapStyle","length","BASEMAP","POSITRON","_loadAnimatedData","entireDataset","idList","map","item","id","idListShorten","arrayShuffle","slice","promisedData","forEach","url","push","Promise","resolve","load","JSONLoader","all","then","values","_createTimeArrays","index","timelineValues","Object","entries","properties","key","value","startsWith","d_timeline","modified_height","h_cop30m","setState","_animate","time","window","requestAnimationFrame","_loadTIFData","a","fromUrl","tiffData","getImage","imageData","getBoundingBox","console","error","_loadShpData","ShapefileLoader","data","_loadData","reject","flat","this","layers","PointCloudLayer","pickable","coordinateSystem","COORDINATE_SYSTEM","LNGLAT","pointSize","getPosition","d","geometry","coordinates","getColor","vel_avg","rgb","initialViewState","controller","mapboxApiAccessToken","toLocaleString","Component","ReactDOM","render","StrictMode","document","getElementById"],"mappings":"gkBAkBMA,EAAqB,CACvBC,UAAW,UACXC,SAAU,QACVC,KAAM,IAkBNC,EAAgB,EAChBC,EAAa,IACbC,EAAe,EACfC,EAAgB,GAEhBC,EAAiB,EACjBC,EAAc,EAMZC,EAAU,8CAEVC,EAAa,CAGf,qCAWEC,EAAc,sCAEhBC,EAAaC,IACZC,MAAM,CAAC,UAAW,UAAW,UAAW,UAAW,UAAW,YAC9DC,OAAO,EAAE,GAAI,KAEFC,cAAcD,OAAO,EAAE,GAAI,KAAKE,MAAM,CAAC,EAAG,IAEnCJ,IAClBC,MAAM,CAAC,UAAW,UAAW,UAAW,YACxCC,OAAO,CAAC,EAAG,K,IASKG,E,4MACjBC,MAAQ,CACJC,SAAU,GACVC,aAAc,GACdC,QAAS,GACTC,YAAa,GACbC,mBAAoB,GACpBC,SA5CoB,GA4CUC,OAAS,EAAI,sCAAwCC,IAAQC,U,EA4C/FC,kBAAoB,SAACC,GACjB,IAAIC,EAASD,EAAcE,KAAI,SAACC,GAAD,OAAUA,EAAKC,MAC1CC,EAAgBC,YAAaL,GAAQM,MAAM,EArGzB,KAuGlBC,EAAe,GAQnB,OAPAH,EAAcI,SAAQ,SAACL,GAEnB,IAAMM,EAAG,2FAAuFN,EAAvF,SACTI,EAAaG,KACT,IAAIC,SAAQ,SAACC,GAAD,OAAaA,EAAQC,YAAKJ,EAAKK,aAG5CH,QAAQI,IAAIR,GAAcS,MAAK,SAACC,GAAD,OAAYA,M,EAGtDC,kBAAoB,WAChB,IAAI5B,EAAe,EAAKF,MAAME,aAC9BA,EAAakB,SAAQ,SAACN,EAAMiB,GACxB,IAAIC,EAAiB,GACrBC,OAAOC,QAAQpB,EAAKqB,YAAYf,SAAQ,YAAmB,IAAD,mBAAhBgB,EAAgB,KAAXC,EAAW,KAClDD,EAAIE,WAAW,QACfN,EAAeV,KAAc,MAATe,EAAgB,EAAIA,GAC1B,IAAVN,GAAa5C,EAAcmC,KAAKc,OAG9B,IAAVL,IAAa9C,EAAa+C,EAAezB,QAC7CL,EAAa6B,GAAOQ,WAAaP,EACjC9B,EAAa6B,GAAOS,gBAAkB1B,EAAKqB,WAAWM,SAAW,OAIrE,EAAKC,SAAS,CAACxC,kB,EAInByC,SAAW,SAACC,GACR,GAAIA,EAAO5D,EAxII,IAyIX6D,OAAOC,sBAAsB,EAAKH,cADtC,CAKA3D,EAAgB4D,EAEZ1D,EAAeD,EAAYC,IAC1BA,EAAe,EAEpB,IAAIgB,EAAY,YAAO,EAAKF,MAAME,cAClCA,EAAakB,SAAQ,SAACN,EAAMiB,GACH,IAAjB7C,IACAgB,EAAa6B,GAAOS,gBAAkB1B,EAAKqB,WAAWM,SAAW,KAMjEvC,EAAa6B,GAAOS,gBAChB1B,EAAK0B,gBAAkB1B,EAAKyB,WAAWrD,MAMnD,EAAKwD,SAAS,CAACxC,iBACf2C,OAAOC,sBAAsB,EAAKH,Y,EAGtCI,a,sBAAe,8BAAAC,EAAA,+EAEcC,YAAQzD,GAFtB,cAEH0D,EAFG,gBAGeA,EAASC,WAHxB,cAGHC,EAHG,OAKP,EAAKV,SAAS,CAACrC,mBAAoB+C,EAAUC,mBALtC,kBAMAD,GANA,yCAQPE,QAAQC,MAAR,MARO,kBASA,IATA,0D,EAafC,a,sBAAe,4BAAAR,EAAA,sEACcvB,YAAKnC,EAASmE,KAD5B,cACPtC,EADO,OAEX/B,EAAiB+B,EAAauC,KAAKnD,OAFxB,kBAGJY,EAAauC,MAHT,2C,EAMfC,U,sBAAY,4BAAAX,EAAA,6DACJ7B,EAAe,GACnB5B,EAAW6B,SAAQ,SAACC,GAAD,OACfF,EAAaG,KACT,IAAIC,SAAQ,SAACC,EAASoC,GAAV,OAAqBpC,EAAQC,YAAKJ,EAAKK,aAJnD,kBAODH,QAAQI,IAAIR,GAAcS,MAAK,SAACC,GACnC,IAAM6B,EAAO7B,EAAOgC,OAEpB,OADAxE,EAAcqE,EAAKnD,OACZmD,MAVH,2C,uDA9HZ,WAAqB,IAAD,OAEZI,KAAKH,YAAY/B,MAAK,SAAC8B,GACnB,EAAKhB,SAAS,CAACzC,SAAUyD,IAErB,EAAKhD,kBAAkBgD,GAAM9B,MAAK,SAAC1B,GAC/Bb,EAAca,EAAaK,OAC3B,EAAKmC,SAAS,CAACxC,iBACf,EAAK4B,oBACLe,OAAOC,sBAAsB,EAAKH,kB,kCA6BtD,c,oBAsGA,WACI,IAAIoB,EAAS,GAgNb,OA9MID,KAAK9D,MAAMI,YAAYG,OAkBvBuD,KAAK9D,MAAME,aAAaK,OAAS,GACjCwD,EAAOzC,KACH,IAAI0C,IAAgB,CAChBjD,GAAI,iBACJ2C,KAAMI,KAAK9D,MAAME,aACjB+D,UAAU,EACVC,iBAAkBC,IAAkBC,OACpCC,UAAuC,EACvCC,YAAa,SAACC,GAAD,4BAAWA,EAAEC,SAASC,aAAtB,CAAmCF,EAAE/B,mBAClDkC,SAAU,SAACH,GAAD,OAAO9E,EAAW8E,EAAEpC,WAAWwC,SAASC,UAqB1Dd,KAAK9D,MAAMG,QAAQI,OAoBnBuD,KAAK9D,MAAMI,YAAYG,OAkBvBuD,KAAK9D,MAAMC,SAASM,OAyHpB,8BACI,eAAC,IAAD,CACIsE,iBAAkBjG,EAClBkG,YAAY,EACZf,OAAQA,EAHZ,UAQI,cAAC,IAAD,CACIgB,qBAvZI,GAwZJzE,SAAUwD,KAAK9D,MAAMM,WACzB,kDAAqBnB,EAAcD,MACnC,+CAAkBG,EAAY2F,oBAC9B,kDAAqB5F,EAAe4F,6B,GAtXvBC,aClFjCC,IAASC,OACP,cAAC,IAAMC,WAAP,UACE,cAAC,EAAD,MAEFC,SAASC,eAAe,W","file":"static/js/main.a5657483.chunk.js","sourcesContent":["import React, {Component} from \"react\";\r\nimport DeckGL from \"@deck.gl/react\";\r\nimport {GeoJsonLayer, ColumnLayer, PointCloudLayer} from \"@deck.gl/layers\";\r\nimport {HeatmapLayer, HexagonLayer} from \"@deck.gl/aggregation-layers\";\r\nimport {StaticMap} from \"react-map-gl\";\r\nimport {TerrainLayer} from \"@deck.gl/geo-layers\";\r\nimport {ShapefileLoader} from \"@loaders.gl/shapefile\";\r\nimport {JSONLoader} from \"@loaders.gl/json\";\r\nimport chroma from \"chroma-js\";\r\nimport {load} from \"@loaders.gl/core\";\r\nimport {COORDINATE_SYSTEM} from \"@deck.gl/core\";\r\nimport {fromUrl} from \"geotiff\";\r\nimport {SimpleMeshLayer} from \"@deck.gl/mesh-layers\";\r\nimport {OBJLoader} from \"@loaders.gl/obj\";\r\nimport {scaleLinear} from \"d3-scale\";\r\nimport arrayShuffle from \"array-shuffle\";\r\nimport {BASEMAP} from '@deck.gl/carto';\r\n\r\nconst INITIAL_VIEW_STATE = {\r\n    longitude: 120.81321,\r\n    latitude: 14.7569,\r\n    zoom: 10,\r\n};\r\n\r\nconst COLUMNS = false;\r\nconst HEATMAP = false;\r\nconst HEXAGONS = false;\r\nconst POINTS = false;\r\nconst TERRAIN = false;\r\nconst BUILDINGS = false;\r\nconst POINTCLOUD = false;\r\nconst ARROW = false;\r\nconst ANIMATED_POINTS = true;\r\nconst FAKED_ANIMATED_POINTS = false;\r\nconst FAKE_ANIMATED_POINTS_COUNT = 400000;\r\n\r\n//animation constants\r\nconst FRAME_MIN_TIME = 100;\r\nconst ANIMATED_POINTS_COUNT = 1000;\r\nlet lastFrameTime = 0;\r\nlet frameCount = 1000;\r\nlet currentFrame = 0;\r\nlet timelineDates = [];\r\n\r\nlet buildingsCount = 0;\r\nlet pointsCount = 0;\r\n\r\n// if you want to use mapbox background layers fill in your mapbox token\r\n// when MAPBOX_ACCESS_TOKEN is empty, background layer from \"CARTO basemaps\" is used instead\r\nconst MAPBOX_ACCESS_TOKEN = \"\";\r\n\r\nconst SHP_URL = \"./data/manila_buildings_larger_than_250.shp\";\r\n\r\nconst POINT_URLS = [\r\n    // \"./data/od_Michala/142.json\",\r\n    // \"./data/od_Michala/32.json\",\r\n    \"./data/interferometry/los/32.json\",\r\n    // \"http://localhost:4445/ftpstorage/applications/emsn091Manila/interferometry/los/142.json\",\r\n    // \"http://localhost:4445/ftpstorage/applications/emsn091Manila/interferometry/vertg/142.json\",\r\n    // \"http://localhost:4445/ftpstorage/applications/emsn091Manila/interferometry/vertg/32.json\",\r\n    // \"http://localhost:4445/ftpstorage/applications/emsn091Manila/interferometry/los/142_decimated.json\",\r\n    // \"http://localhost:4445/ftpstorage/applications/emsn091Manila/interferometry/los/32.json\",\r\n    // \"http://localhost:4445/ftpstorage/applications/emsn091Manila/interferometry/los/142.json\",\r\n    // \"http://localhost:4445/ftpstorage/applications/emsn091Manila/interferometry/vertg/142.json\",\r\n    // \"http://localhost:4445/ftpstorage/applications/emsn091Manila/interferometry/vertg/32.json\",\r\n];\r\n\r\nconst TERRAIN_URL = \"./data/Copernicus_DSM_10_merged.tif\";\r\n\r\nlet colorScale = chroma\r\n    .scale([\"#fda34b\", \"#ff7882\", \"#c8699e\", \"#7046aa\", \"#0c1db8\", \"#2eaaac\"])\r\n    .domain([-30, 10]);\r\n\r\nlet sizeScale = scaleLinear().domain([-30, 10]).range([4, 1]);\r\n\r\nlet heightColorScale = chroma\r\n    .scale([\"#A0FAB4\", \"#88CA97\", \"#6E9B78\", \"#536E59\"])\r\n    .domain([0, 20]);\r\n\r\n\r\nfunction getRandomInt(min, max) {\r\n    min = Math.ceil(min);\r\n    max = Math.floor(max);\r\n    return Math.floor(Math.random() * (max - min + 1)) + min;\r\n}\r\n\r\nexport default class App extends Component {\r\n    state = {\r\n        jsonData: [],\r\n        animatedData: [],\r\n        shpData: [],\r\n        terrainData: [],\r\n        terrainBoundingBox: [],\r\n        mapStyle: MAPBOX_ACCESS_TOKEN.length > 0 ? 'mapbox://styles/mapbox/satellite-v9' : BASEMAP.POSITRON\r\n    };\r\n\r\n    componentDidMount() {\r\n        if (POINTS || POINTCLOUD || COLUMNS || HEXAGONS || HEATMAP || ARROW || ANIMATED_POINTS || FAKED_ANIMATED_POINTS) {\r\n            this._loadData().then((data) => {\r\n                this.setState({jsonData: data});\r\n                if (ANIMATED_POINTS) {\r\n                    this._loadAnimatedData(data).then((animatedData) => {\r\n                        pointsCount = animatedData.length\r\n                        this.setState({animatedData});\r\n                        this._createTimeArrays();\r\n                        window.requestAnimationFrame(this._animate);\r\n                    });\r\n                }\r\n                if (FAKED_ANIMATED_POINTS) {\r\n                    let animatedData = (arrayShuffle(data)).slice(0, FAKE_ANIMATED_POINTS_COUNT)\r\n                    pointsCount = animatedData.length\r\n                    animatedData.forEach((value, index) => {\r\n                        animatedData[index].modified_height = value.properties.h_cop30m + 50000\r\n                    })\r\n                    this.setState({animatedData})\r\n                    window.requestAnimationFrame(this._animate);\r\n                }\r\n            });\r\n        }\r\n\r\n        if (BUILDINGS) {\r\n            this._loadShpData().then((shpData) => {\r\n                this.setState({shpData});\r\n            });\r\n        }\r\n\r\n        if (TERRAIN) {\r\n            this._loadTIFData().then((terrainData) => {\r\n                debugger;\r\n                this.setState({terrainData});\r\n            });\r\n        }\r\n    }\r\n\r\n    componentWillUnmount() {\r\n    }\r\n\r\n    _loadAnimatedData = (entireDataset) => {\r\n        let idList = entireDataset.map((item) => item.id);\r\n        let idListShorten = arrayShuffle(idList).slice(0, ANIMATED_POINTS_COUNT);\r\n\r\n        let promisedData = [];\r\n        idListShorten.forEach((id) => {\r\n            // const url = `./data/interferometry/los/32/${id}.json`24\r\n            const url = `https://ptr.gisat.cz/ftpstorage/applications/emsn091Manila/interferometry/los/32/${id}.json`;\r\n            promisedData.push(\r\n                new Promise((resolve) => resolve(load(url, JSONLoader)))\r\n            );\r\n        });\r\n        return Promise.all(promisedData).then((values) => values);\r\n    };\r\n\r\n    _createTimeArrays = () => {\r\n        let animatedData = this.state.animatedData;\r\n        animatedData.forEach((item, index) => {\r\n            let timelineValues = [];\r\n            Object.entries(item.properties).forEach(([key, value]) => {\r\n                if (key.startsWith(\"d_\")) {\r\n                    timelineValues.push(value == null ? 0 : value);\r\n                    if (index === 0) timelineDates.push(key);\r\n                }\r\n            });\r\n            if (index === 0) frameCount = timelineValues.length;\r\n            animatedData[index].d_timeline = timelineValues;\r\n            animatedData[index].modified_height = item.properties.h_cop30m + 50000;\r\n            // animatedData[index].coordinate_update = timelineValues[0];\r\n        });\r\n\r\n        this.setState({animatedData});\r\n    };\r\n\r\n\r\n    _animate = (time) => {\r\n        if (time - lastFrameTime < FRAME_MIN_TIME) {\r\n            window.requestAnimationFrame(this._animate);\r\n            return;\r\n        }\r\n\r\n        lastFrameTime = time;\r\n\r\n        if (currentFrame < frameCount) currentFrame++;\r\n        else currentFrame = 0;\r\n\r\n        let animatedData = [...this.state.animatedData];\r\n        animatedData.forEach((item, index) => {\r\n            if (currentFrame === 0) {\r\n                animatedData[index].modified_height = item.properties.h_cop30m + 50000;\r\n            }\r\n            if (FAKED_ANIMATED_POINTS) {\r\n                animatedData[index].modified_height =\r\n                    item.modified_height + getRandomInt(-2000, 2000)\r\n            } else {\r\n                animatedData[index].modified_height =\r\n                    item.modified_height + item.d_timeline[currentFrame];\r\n            }\r\n\r\n            // animatedData[index].properties.color = chroma.random().rgb();\r\n        });\r\n\r\n        this.setState({animatedData});\r\n        window.requestAnimationFrame(this._animate);\r\n    };\r\n\r\n    _loadTIFData = async () => {\r\n        try {\r\n            let tiffData = await fromUrl(TERRAIN_URL);\r\n            let imageData = await tiffData.getImage();\r\n            debugger;\r\n            this.setState({terrainBoundingBox: imageData.getBoundingBox()});\r\n            return imageData;\r\n        } catch (err) {\r\n            console.error(err);\r\n            return [];\r\n        }\r\n    };\r\n\r\n    _loadShpData = async () => {\r\n        let promisedData = await load(SHP_URL, ShapefileLoader);\r\n        buildingsCount = promisedData.data.length\r\n        return promisedData.data;\r\n    };\r\n\r\n    _loadData = async () => {\r\n        let promisedData = [];\r\n        POINT_URLS.forEach((url) =>\r\n            promisedData.push(\r\n                new Promise((resolve, reject) => resolve(load(url, JSONLoader)))\r\n            )\r\n        );\r\n        return Promise.all(promisedData).then((values) => {\r\n            const data = values.flat();\r\n            pointsCount = data.length;\r\n            return data;\r\n        });\r\n    };\r\n\r\n    render() {\r\n        let layers = [];\r\n\r\n        if (this.state.terrainData.length > 0 && TERRAIN) {\r\n            layers.push(\r\n                new TerrainLayer({\r\n                    elevationDecoder: {\r\n                        rScaler: 2,\r\n                        gScaler: 0,\r\n                        bScaler: 0,\r\n                        offset: 0,\r\n                    },\r\n                    // Digital elevation model from https://www.usgs.gov/\r\n                    elevationData: this.state.terrainData,\r\n                    texture:\r\n                        \"https://raw.githubusercontent.com/visgl/deck.gl-data/master/website/terrain-mask.png\",\r\n                    bounds: this.state.terrainBoundingBox,\r\n                })\r\n            );\r\n        }\r\n\r\n        if (this.state.animatedData.length > 0 && (ANIMATED_POINTS || FAKED_ANIMATED_POINTS)) {\r\n            layers.push(\r\n                new PointCloudLayer({\r\n                    id: \"animated-layer\",\r\n                    data: this.state.animatedData,\r\n                    pickable: false,\r\n                    coordinateSystem: COORDINATE_SYSTEM.LNGLAT,\r\n                    pointSize: FAKED_ANIMATED_POINTS ? 1 : 6,\r\n                    getPosition: (d) => [...d.geometry.coordinates, d.modified_height],\r\n                    getColor: (d) => colorScale(d.properties.vel_avg).rgb(),\r\n                })\r\n            );\r\n\r\n            // layers.push(\r\n            //   new ColumnLayer({\r\n            //     id: \"animated-column-layer\",\r\n            //     data: this.state.animatedData,\r\n            //     diskResolution: 12,\r\n            //     radius: 250,\r\n            //     extruded: true,\r\n            //     pickable: true,\r\n            //     elevationScale: 500,\r\n            //     getPosition: (d) => d.geometry.coordinates,\r\n            //     getFillColor: (d) => colorScale(d.properties.vel_avg).rgb(),\r\n            //     getLineColor: [0, 0, 0],\r\n            //     getElevation: (d) => d.modified_height / 500,\r\n            //   })\r\n            // );\r\n        }\r\n\r\n        if (this.state.shpData.length > 0) {\r\n            if (BUILDINGS) {\r\n                layers.push(\r\n                    new GeoJsonLayer({\r\n                        id: \"buildings-geojson-layer\",\r\n                        data: this.state.shpData,\r\n                        pickable: false,\r\n                        filled: true,\r\n                        extruded: true,\r\n                        getFillColor: (d) => [\r\n                            ...heightColorScale(Math.random() * 20).rgb(),\r\n                            255,\r\n                        ],\r\n                        getElevation: (d) => Math.random() * 20,\r\n                        elevationScale: 3,\r\n                    })\r\n                );\r\n            }\r\n        }\r\n\r\n        if (this.state.terrainData.length > 0 && TERRAIN) {\r\n            layers.push(\r\n                new TerrainLayer({\r\n                    elevationDecoder: {\r\n                        rScaler: 2,\r\n                        gScaler: 0,\r\n                        bScaler: 0,\r\n                        offset: 0,\r\n                    },\r\n                    // Digital elevation model from https://www.usgs.gov/\r\n                    elevationData: this.state.terrainData,\r\n                    texture:\r\n                        \"https://raw.githubusercontent.com/visgl/deck.gl-data/master/website/terrain-mask.png\",\r\n                    bounds: this.state.terrainBoundingBox,\r\n                })\r\n            );\r\n        }\r\n\r\n        if (this.state.jsonData.length > 0) {\r\n            if (HEATMAP) {\r\n                layers.push(\r\n                    new HeatmapLayer({\r\n                        id: \"heatmapLayer\",\r\n                        data: this.state.jsonData,\r\n                        getPosition: (d) => d.geometry.coordinates,\r\n                        getWeight: (d) => d.properties.vel_avg,\r\n                        aggregation: \"MEAN\",\r\n                    })\r\n                );\r\n            }\r\n\r\n            if (HEXAGONS) {\r\n                layers.push(\r\n                    new HexagonLayer({\r\n                        id: \"hexagon-layer\",\r\n                        data: this.state.jsonData,\r\n                        pickable: true,\r\n                        extruded: true,\r\n                        radius: 200,\r\n                        elevationScale: 4,\r\n                        getColorWeight: (d) => d.properties.vel_avg,\r\n                        colorAggregation: \"MEAN\",\r\n                        getElevationWeight: (d) => d.properties.vel_avg,\r\n                        elevationAggregation: \"SUM\",\r\n                        elevationDomain: [-30, 10],\r\n                        colorDomain: [-30, 10],\r\n                        colorScale: [\r\n                            \"#fda34b\",\r\n                            \"#ff7882\",\r\n                            \"#c8699e\",\r\n                            \"#7046aa\",\r\n                            \"#0c1db8\",\r\n                            \"#2eaaac\",\r\n                        ],\r\n                        getPosition: (d) => d.geometry.coordinates,\r\n                    })\r\n                );\r\n            }\r\n\r\n            if (COLUMNS) {\r\n                layers.push(\r\n                    new ColumnLayer({\r\n                        id: \"column-layer\",\r\n                        data: this.state.jsonData,\r\n                        diskResolution: 12,\r\n                        radius: 250,\r\n                        extruded: true,\r\n                        pickable: true,\r\n                        elevationScale: 500,\r\n                        getPosition: (d) => d.geometry.coordinates,\r\n                        getFillColor: (d) => colorScale(d.properties.vel_avg).rgb(),\r\n                        getLineColor: [0, 0, 0],\r\n                        getElevation: (d) => 40 + d.properties.vel_avg,\r\n                    })\r\n                );\r\n            }\r\n\r\n            if (POINTCLOUD) {\r\n                layers.push(\r\n                    new PointCloudLayer({\r\n                        id: \"point-cloud-layer\",\r\n                        data: this.state.jsonData,\r\n                        pickable: false,\r\n                        coordinateSystem: COORDINATE_SYSTEM.LNGLAT,\r\n                        pointSize: 2,\r\n                        getPosition: (d) => [\r\n                            ...d.geometry.coordinates,\r\n                            10 + d.properties.h_cop30m * 75,\r\n                        ],\r\n                        getColor: (d) => colorScale(d.properties.vel_avg).rgb(),\r\n                    })\r\n                );\r\n            }\r\n\r\n            if (ARROW) {\r\n                layers.push(\r\n                    new SimpleMeshLayer({\r\n                        id: \"mesh-layer\",\r\n                        data: this.state.jsonData,\r\n                        mesh: \"./obj/arrow.obj\",\r\n                        loaders: [OBJLoader],\r\n                        getScale: (d) => [1, sizeScale(d.properties.vel_avg), 1],\r\n                        sizeScale: 100,\r\n                        getPosition: (d) => d.geometry.coordinates,\r\n                        getColor: (d) => colorScale(d.properties.vel_avg).rgb(),\r\n                        getOrientation: (d) => [\r\n                            0,\r\n                            d.properties.az_ang,\r\n                            d.properties.inc_ang,\r\n                        ],\r\n                        getTranslation: (d) => [0, 0, d.properties.h_cop30m * 100],\r\n                    })\r\n                );\r\n            }\r\n\r\n            if (POINTS) {\r\n                layers.push(\r\n                    new GeoJsonLayer({\r\n                        id: \"points-geojson-layer\",\r\n                        data: this.state.jsonData,\r\n                        pickable: true,\r\n                        stroked: false,\r\n                        filled: true,\r\n                        extruded: true,\r\n                        pointType: \"circle\",\r\n                        lineWidthScale: 20,\r\n                        lineWidthMinPixels: 2,\r\n                        elevationValue: (d) => Math.random() * 100,\r\n                        getFillColor: (d) => [\r\n                            ...colorScale(d.properties.vel_avg).rgb(),\r\n                            255,\r\n                        ],\r\n                        getPointRadius: 20,\r\n                    })\r\n                );\r\n            }\r\n        }\r\n\r\n        return (\r\n            <div>\r\n                <DeckGL\r\n                    initialViewState={INITIAL_VIEW_STATE}\r\n                    controller={true}\r\n                    layers={layers}\r\n                    // getTooltip={({ object }) =>\r\n                    //   object && `Vel avg: ${object.properties.vel_avg}`\r\n                    // }\r\n                >\r\n                    <StaticMap\r\n                        mapboxApiAccessToken={MAPBOX_ACCESS_TOKEN}\r\n                        mapStyle={this.state.mapStyle}/>\r\n                    <p>measurement time:{timelineDates[currentFrame]}</p>\r\n                    <p>points count: {pointsCount.toLocaleString()}</p>\r\n                    <p>buildings count: {buildingsCount.toLocaleString()}</p>\r\n\r\n                </DeckGL>\r\n            </div>\r\n        );\r\n    }\r\n}\r\n","import React from \"react\";\r\nimport ReactDOM from \"react-dom\";\r\nimport App from \"./App\";\r\n\r\nReactDOM.render(\r\n  <React.StrictMode>\r\n    <App />\r\n  </React.StrictMode>,\r\n  document.getElementById(\"root\")\r\n);\r\n"],"sourceRoot":""}