{"version":3,"sources":["App.js","index.js"],"names":["INITIAL_VIEW_STATE","longitude","latitude","zoom","lastFrameTime","frameCount","currentFrame","timelineDates","buildingsCount","pointsCount","SHP_URL","POINT_URLS","TERRAIN_URL","colorScale","chroma","scale","domain","scaleLinear","range","App","state","jsonData","animatedData","shpData","terrainData","terrainBoundingBox","_loadAnimatedData","entireDataset","idList","map","item","id","idListShorten","arrayShuffle","slice","promisedData","forEach","url","push","Promise","resolve","load","JSONLoader","all","then","values","_createTimeArrays","index","timelineValues","Object","entries","properties","key","value","startsWith","length","d_timeline","modified_height","h_cop30m","setState","_animate","time","window","requestAnimationFrame","_loadTIFData","a","fromUrl","tiffData","getImage","imageData","getBoundingBox","console","error","_loadShpData","ShapefileLoader","data","_loadData","reject","flat","this","layers","PointCloudLayer","pickable","coordinateSystem","COORDINATE_SYSTEM","LNGLAT","pointSize","getPosition","d","geometry","coordinates","getColor","vel_avg","rgb","initialViewState","controller","mapboxApiAccessToken","mapStyle","toLocaleString","Component","ReactDOM","render","StrictMode","document","getElementById"],"mappings":"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","file":"static/js/main.607cc54e.chunk.js","sourcesContent":["import React, {Component} from \"react\";\nimport DeckGL from \"@deck.gl/react\";\nimport {GeoJsonLayer, ColumnLayer, PointCloudLayer} from \"@deck.gl/layers\";\nimport {HeatmapLayer, HexagonLayer} from \"@deck.gl/aggregation-layers\";\nimport {StaticMap} from \"react-map-gl\";\nimport {TerrainLayer} from \"@deck.gl/geo-layers\";\nimport {ShapefileLoader} from \"@loaders.gl/shapefile\";\nimport {JSONLoader} from \"@loaders.gl/json\";\nimport chroma from \"chroma-js\";\nimport {load} from \"@loaders.gl/core\";\nimport {COORDINATE_SYSTEM} from \"@deck.gl/core\";\nimport {fromUrl} from \"geotiff\";\nimport {SimpleMeshLayer} from \"@deck.gl/mesh-layers\";\nimport {OBJLoader} from \"@loaders.gl/obj\";\nimport {scaleLinear} from \"d3-scale\";\nimport arrayShuffle from \"array-shuffle\";\n\nconst INITIAL_VIEW_STATE = {\n    longitude: 120.81321,\n    latitude: 14.7569,\n    zoom: 10,\n};\n\nconst COLUMNS = false;\nconst HEATMAP = false;\nconst HEXAGONS = false;\nconst POINTS = false;\nconst TERRAIN = false;\nconst BUILDINGS = false;\nconst POINTCLOUD = false;\nconst ARROW = false;\nconst ANIMATED_POINTS = true;\nconst FAKED_ANIMATED_POINTS = false;\nconst FAKE_ANIMATED_POINTS_COUNT = 400000;\n\n//animation constants\nconst FRAME_MIN_TIME = 100;\nconst ANIMATED_POINTS_COUNT = 1000;\nlet lastFrameTime = 0;\nlet frameCount = 1000;\nlet currentFrame = 0;\nlet timelineDates = [];\n\nlet buildingsCount = 0;\nlet pointsCount = 0;\n\nconst MAPBOX_ACCESS_TOKEN =\n    \"pk.eyJ1IjoibWFyaWRhbmkiLCJhIjoiSGF2TGdwZyJ9.B0N8ybRGG38wmRK_VfxPoA\";\n\nconst SHP_URL = \"./data/manila_buildings_larger_than_250.shp\";\n\nconst POINT_URLS = [\n    // \"./data/od_Michala/142.json\",\n    // \"./data/od_Michala/32.json\",\n    \"./data/interferometry/los/32.json\",\n    // \"http://localhost:4445/ftpstorage/applications/emsn091Manila/interferometry/los/142.json\",\n    // \"http://localhost:4445/ftpstorage/applications/emsn091Manila/interferometry/vertg/142.json\",\n    // \"http://localhost:4445/ftpstorage/applications/emsn091Manila/interferometry/vertg/32.json\",\n    // \"http://localhost:4445/ftpstorage/applications/emsn091Manila/interferometry/los/142_decimated.json\",\n    // \"http://localhost:4445/ftpstorage/applications/emsn091Manila/interferometry/los/32.json\",\n    // \"http://localhost:4445/ftpstorage/applications/emsn091Manila/interferometry/los/142.json\",\n    // \"http://localhost:4445/ftpstorage/applications/emsn091Manila/interferometry/vertg/142.json\",\n    // \"http://localhost:4445/ftpstorage/applications/emsn091Manila/interferometry/vertg/32.json\",\n];\n\nconst TERRAIN_URL = \"./data/Copernicus_DSM_10_merged.tif\";\n\nlet colorScale = chroma\n    .scale([\"#fda34b\", \"#ff7882\", \"#c8699e\", \"#7046aa\", \"#0c1db8\", \"#2eaaac\"])\n    .domain([-30, 10]);\n\nlet sizeScale = scaleLinear().domain([-30, 10]).range([4, 1]);\n\nlet heightColorScale = chroma\n    .scale([\"#A0FAB4\", \"#88CA97\", \"#6E9B78\", \"#536E59\"])\n    .domain([0, 20]);\n\n\nfunction getRandomInt(min, max) {\n    min = Math.ceil(min);\n    max = Math.floor(max);\n    return Math.floor(Math.random() * (max - min + 1)) + min;\n}\n\nexport default class App extends Component {\n    state = {\n        jsonData: [],\n        animatedData: [],\n        shpData: [],\n        terrainData: [],\n        terrainBoundingBox: [],\n    };\n\n    componentDidMount() {\n        if (POINTS || POINTCLOUD || COLUMNS || HEXAGONS || HEATMAP || ARROW || ANIMATED_POINTS || FAKED_ANIMATED_POINTS) {\n            this._loadData().then((data) => {\n                this.setState({jsonData: data});\n                if (ANIMATED_POINTS) {\n                    this._loadAnimatedData(data).then((animatedData) => {\n                        pointsCount = animatedData.length\n                        this.setState({animatedData});\n                        this._createTimeArrays();\n                        window.requestAnimationFrame(this._animate);\n                    });\n                }\n                if (FAKED_ANIMATED_POINTS) {\n                    let animatedData = (arrayShuffle(data)).slice(0, FAKE_ANIMATED_POINTS_COUNT)\n                    pointsCount = animatedData.length\n                    animatedData.forEach((value, index) => {\n                        animatedData[index].modified_height = value.properties.h_cop30m + 50000\n                    })\n                    this.setState({animatedData})\n                    window.requestAnimationFrame(this._animate);\n                }\n            });\n        }\n\n        if (BUILDINGS) {\n            this._loadShpData().then((shpData) => {\n                this.setState({shpData});\n            });\n        }\n\n        if (TERRAIN) {\n            this._loadTIFData().then((terrainData) => {\n                debugger;\n                this.setState({terrainData});\n            });\n        }\n    }\n\n    componentWillUnmount() {\n    }\n\n    _loadAnimatedData = (entireDataset) => {\n        let idList = entireDataset.map((item) => item.id);\n        let idListShorten = arrayShuffle(idList).slice(0, ANIMATED_POINTS_COUNT);\n\n        let promisedData = [];\n        idListShorten.forEach((id) => {\n            // const url = `./data/interferometry/los/32/${id}.json`24\n            const url = `https://ptr.gisat.cz/ftpstorage/applications/emsn091Manila/interferometry/los/32/${id}.json`;\n            promisedData.push(\n                new Promise((resolve) => resolve(load(url, JSONLoader)))\n            );\n        });\n        return Promise.all(promisedData).then((values) => values);\n    };\n\n    _createTimeArrays = () => {\n        let animatedData = this.state.animatedData;\n        animatedData.forEach((item, index) => {\n            let timelineValues = [];\n            Object.entries(item.properties).forEach(([key, value]) => {\n                if (key.startsWith(\"d_\")) {\n                    timelineValues.push(value == null ? 0 : value);\n                    if (index === 0) timelineDates.push(key);\n                }\n            });\n            if (index === 0) frameCount = timelineValues.length;\n            animatedData[index].d_timeline = timelineValues;\n            animatedData[index].modified_height = item.properties.h_cop30m + 50000;\n            // animatedData[index].coordinate_update = timelineValues[0];\n        });\n\n        this.setState({animatedData});\n    };\n\n\n    _animate = (time) => {\n        if (time - lastFrameTime < FRAME_MIN_TIME) {\n            window.requestAnimationFrame(this._animate);\n            return;\n        }\n\n        lastFrameTime = time;\n\n        if (currentFrame < frameCount) currentFrame++;\n        else currentFrame = 0;\n\n        let animatedData = [...this.state.animatedData];\n        animatedData.forEach((item, index) => {\n            if (currentFrame === 0) {\n                animatedData[index].modified_height = item.properties.h_cop30m + 50000;\n            }\n            if (FAKED_ANIMATED_POINTS){\n                animatedData[index].modified_height =\n                    item.modified_height + getRandomInt(-2000,2000)\n            }\n            else {\n                animatedData[index].modified_height =\n                    item.modified_height + item.d_timeline[currentFrame];\n            }\n\n            // animatedData[index].properties.color = chroma.random().rgb();\n        });\n\n        this.setState({animatedData});\n        window.requestAnimationFrame(this._animate);\n    };\n\n    _loadTIFData = async () => {\n        try {\n            let tiffData = await fromUrl(TERRAIN_URL);\n            let imageData = await tiffData.getImage();\n            debugger;\n            this.setState({terrainBoundingBox: imageData.getBoundingBox()});\n            return imageData;\n        } catch (err) {\n            console.error(err);\n            return [];\n        }\n    };\n\n    _loadShpData = async () => {\n        let promisedData = await load(SHP_URL, ShapefileLoader);\n        buildingsCount = promisedData.data.length\n        return promisedData.data;\n    };\n\n    _loadData = async () => {\n        let promisedData = [];\n        POINT_URLS.forEach((url) =>\n            promisedData.push(\n                new Promise((resolve, reject) => resolve(load(url, JSONLoader)))\n            )\n        );\n        return Promise.all(promisedData).then((values) => {\n            const data = values.flat();\n            pointsCount = data.length;\n            return data;\n        });\n    };\n\n    render() {\n        let layers = [];\n\n        if (this.state.terrainData.length > 0 && TERRAIN) {\n            layers.push(\n                new TerrainLayer({\n                    elevationDecoder: {\n                        rScaler: 2,\n                        gScaler: 0,\n                        bScaler: 0,\n                        offset: 0,\n                    },\n                    // Digital elevation model from https://www.usgs.gov/\n                    elevationData: this.state.terrainData,\n                    texture:\n                        \"https://raw.githubusercontent.com/visgl/deck.gl-data/master/website/terrain-mask.png\",\n                    bounds: this.state.terrainBoundingBox,\n                })\n            );\n        }\n\n        if (this.state.animatedData.length > 0 && (ANIMATED_POINTS || FAKED_ANIMATED_POINTS)) {\n            layers.push(\n                new PointCloudLayer({\n                    id: \"animated-layer\",\n                    data: this.state.animatedData,\n                    pickable: false,\n                    coordinateSystem: COORDINATE_SYSTEM.LNGLAT,\n                    pointSize: FAKED_ANIMATED_POINTS? 1 : 6,\n                    getPosition: (d) => [...d.geometry.coordinates, d.modified_height],\n                    getColor: (d) => colorScale(d.properties.vel_avg).rgb(),\n                })\n            );\n\n            // layers.push(\n            //   new ColumnLayer({\n            //     id: \"animated-column-layer\",\n            //     data: this.state.animatedData,\n            //     diskResolution: 12,\n            //     radius: 250,\n            //     extruded: true,\n            //     pickable: true,\n            //     elevationScale: 500,\n            //     getPosition: (d) => d.geometry.coordinates,\n            //     getFillColor: (d) => colorScale(d.properties.vel_avg).rgb(),\n            //     getLineColor: [0, 0, 0],\n            //     getElevation: (d) => d.modified_height / 500,\n            //   })\n            // );\n        }\n\n        if (this.state.shpData.length > 0) {\n            if (BUILDINGS) {\n                layers.push(\n                    new GeoJsonLayer({\n                        id: \"buildings-geojson-layer\",\n                        data: this.state.shpData,\n                        pickable: false,\n                        filled: true,\n                        extruded: true,\n                        getFillColor: (d) => [\n                            ...heightColorScale(Math.random() * 20).rgb(),\n                            255,\n                        ],\n                        getElevation: (d) => Math.random() * 20,\n                        elevationScale: 3,\n                    })\n                );\n            }\n        }\n\n        if (this.state.terrainData.length > 0 && TERRAIN) {\n            layers.push(\n                new TerrainLayer({\n                    elevationDecoder: {\n                        rScaler: 2,\n                        gScaler: 0,\n                        bScaler: 0,\n                        offset: 0,\n                    },\n                    // Digital elevation model from https://www.usgs.gov/\n                    elevationData: this.state.terrainData,\n                    texture:\n                        \"https://raw.githubusercontent.com/visgl/deck.gl-data/master/website/terrain-mask.png\",\n                    bounds: this.state.terrainBoundingBox,\n                })\n            );\n        }\n\n        if (this.state.jsonData.length > 0) {\n            if (HEATMAP) {\n                layers.push(\n                    new HeatmapLayer({\n                        id: \"heatmapLayer\",\n                        data: this.state.jsonData,\n                        getPosition: (d) => d.geometry.coordinates,\n                        getWeight: (d) => d.properties.vel_avg,\n                        aggregation: \"MEAN\",\n                    })\n                );\n            }\n\n            if (HEXAGONS) {\n                layers.push(\n                    new HexagonLayer({\n                        id: \"hexagon-layer\",\n                        data: this.state.jsonData,\n                        pickable: true,\n                        extruded: true,\n                        radius: 200,\n                        elevationScale: 4,\n                        getColorWeight: (d) => d.properties.vel_avg,\n                        colorAggregation: \"MEAN\",\n                        getElevationWeight: (d) => d.properties.vel_avg,\n                        elevationAggregation: \"SUM\",\n                        elevationDomain: [-30, 10],\n                        colorDomain: [-30, 10],\n                        colorScale: [\n                            \"#fda34b\",\n                            \"#ff7882\",\n                            \"#c8699e\",\n                            \"#7046aa\",\n                            \"#0c1db8\",\n                            \"#2eaaac\",\n                        ],\n                        getPosition: (d) => d.geometry.coordinates,\n                    })\n                );\n            }\n\n            if (COLUMNS) {\n                layers.push(\n                    new ColumnLayer({\n                        id: \"column-layer\",\n                        data: this.state.jsonData,\n                        diskResolution: 12,\n                        radius: 250,\n                        extruded: true,\n                        pickable: true,\n                        elevationScale: 500,\n                        getPosition: (d) => d.geometry.coordinates,\n                        getFillColor: (d) => colorScale(d.properties.vel_avg).rgb(),\n                        getLineColor: [0, 0, 0],\n                        getElevation: (d) => 40 + d.properties.vel_avg,\n                    })\n                );\n            }\n\n            if (POINTCLOUD) {\n                layers.push(\n                    new PointCloudLayer({\n                        id: \"point-cloud-layer\",\n                        data: this.state.jsonData,\n                        pickable: false,\n                        coordinateSystem: COORDINATE_SYSTEM.LNGLAT,\n                        pointSize: 2,\n                        getPosition: (d) => [\n                            ...d.geometry.coordinates,\n                            10 + d.properties.h_cop30m * 75,\n                        ],\n                        getColor: (d) => colorScale(d.properties.vel_avg).rgb(),\n                    })\n                );\n            }\n\n            if (ARROW) {\n                layers.push(\n                    new SimpleMeshLayer({\n                        id: \"mesh-layer\",\n                        data: this.state.jsonData,\n                        mesh: \"./obj/arrow.obj\",\n                        loaders: [OBJLoader],\n                        getScale: (d) => [1, sizeScale(d.properties.vel_avg), 1],\n                        sizeScale: 100,\n                        getPosition: (d) => d.geometry.coordinates,\n                        getColor: (d) => colorScale(d.properties.vel_avg).rgb(),\n                        getOrientation: (d) => [\n                            0,\n                            d.properties.az_ang,\n                            d.properties.inc_ang,\n                        ],\n                        getTranslation: (d) => [0, 0, d.properties.h_cop30m * 100],\n                    })\n                );\n            }\n\n            if (POINTS) {\n                layers.push(\n                    new GeoJsonLayer({\n                        id: \"points-geojson-layer\",\n                        data: this.state.jsonData,\n                        pickable: true,\n                        stroked: false,\n                        filled: true,\n                        extruded: true,\n                        pointType: \"circle\",\n                        lineWidthScale: 20,\n                        lineWidthMinPixels: 2,\n                        elevationValue: (d) => Math.random() * 100,\n                        getFillColor: (d) => [\n                            ...colorScale(d.properties.vel_avg).rgb(),\n                            255,\n                        ],\n                        getPointRadius: 20,\n                    })\n                );\n            }\n        }\n\n        return (\n            <div>\n                <DeckGL\n                    initialViewState={INITIAL_VIEW_STATE}\n                    controller={true}\n                    layers={layers}\n                    // getTooltip={({ object }) =>\n                    //   object && `Vel avg: ${object.properties.vel_avg}`\n                    // }\n                >\n                    <StaticMap\n                        mapboxApiAccessToken={MAPBOX_ACCESS_TOKEN}\n                        mapStyle={this.state.mapStyle}/>\n                    <p>measurement time:{timelineDates[currentFrame]}</p>\n                    <p>points count: {pointsCount.toLocaleString()}</p>\n                    <p>buildings count: {buildingsCount.toLocaleString()}</p>\n\n                </DeckGL>\n            </div>\n        );\n    }\n}\n","import React from \"react\";\nimport ReactDOM from \"react-dom\";\nimport App from \"./App\";\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById(\"root\")\n);\n"],"sourceRoot":""}